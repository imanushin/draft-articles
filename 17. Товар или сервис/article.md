На хабре (да и в реальной IT жизни) встречаeтся много вопросов вида:

* Надо ли обновлять систему (или зависимости в приложении), если и так всё работает?
* Нужны ли вообще тесты в приложении (вы ведь на них потратите своё время и деньги заказчика)?
* Если ли смысл в паттернах и выделении абстракций (ведь подобное размазывает код, приводит к снижению производительности и т.д.)?

Ключевой вопрос во всех примерах ниже: что вы разрабатываете: товар или сервис? Как ни странно, но как только вы ответите на этот вопрос о товаре и сервисы, все сомнения о необходимости тестов, абстракций и т.д. отпадут сами собой.

<habracut/>

В них есть принципиальная разница: товар обладает законченностью, его можно продать, а потом забыть о его существовании. В случае сервиса, покупатель и продавец общаются долго (по аналогии с подпиской, которая является этим самым сервисом).

Примеры продуктов:

* Строительство моста. Собственно, мост построен, сдан (это принципиально важный шаг), компания-строитель забыла о нем. В реальности еще существует гарантия на постройку, однако для сферичности эксперимента лучше пока сделать вид, что она отсутствует (или же очень короткая).
* Продажа табуретки. Всё аналогично мосту, самое главное - продать эту самую табуретку. После этого продавец забудет про покупателя очень надолго (по крайней мере, в большинстве случаев).
* Продажа квартиры (особенно на вторичном рынке). Тут опять-таки, самое важное - продать квартиру, чтобы она не развалилась в первые месяцы. А что будет дальше - продавцу абсолютно неважно.

Примеры сервисов:

* Банковское обслуживание. Клиент платит за обслуживание раз в месяц, банк предоставляет сервис весь этот месяц. Клиент и банк помнят друг о друге весь месяц, а зачастую и несколько лет. Нет смысла продавать неликвид, ведь клиент откажется от обслуживания довольно быстро.
* Сервис такси (т.е. Яндекс Такс, Gett и пр.). Несмотря на то, что поездки носят законченный характер, компании делают основные деньги на постоянных клиентах, на тех, которые возвращаются. Поэтому нет никакого смысла обманывать покупателя в первую же покупку (в стиле бомбил), так как отношения здесь длительные.
* Супермаркет. Опять-таки, нам длительность общения продавца и покупателя намного важнее сиюминутной выгоды. А этом значит, что вместо продажи испорченного хлеба, магазину выгоднее утилизировать партию. Иначе покупатель купит хлеб в последний раз и не придет в магазин вообще.

# Зачем нам знать разницу между товаром и сервисом?

Идея проста: если вы рассматриваете свою программу как товар (то есть ваша связь с ней прервется после первого релиза), то **нет никакого смысла тратить лишнее время ни на тесты, ни на рефакторинги, ни на соответствие стилям кодирования**. Ведь если вы потратите своё время и сделаете "на отлично", то ваш продукт просто удорожает. А в дальнейшем эти абстракции будут просто вам не нужны (ведь вы-то прекратите работать над программой).

Однако если вы оказываете сервис для пользователей (например, делаете аналог Facebook), то у вас будут задачи обновления зависимостей, у вас будут задачи добавления/удаления функций, а потому тесты всё-таки будут, ибо они снизят риски в долгосрочной перспективе. Более того, вам потребуется выделять абстракции, как минимум для того, чтобы в будущем встраивать новую логику. Итого, если вы рассматриваете свою разработку как сервис, то вам необходимо обновлять зависимости, писать тесты, выделять абстракции и делать немало другой работы по _уходу от legacy_ и минимизации рисков ошибки в будущем.

## Пособие: как сделать из программы legacy своими руками

В контексте этой статьи можно очень легко вывести формулу того, как можно очень просто из практически любого разрабатываемого ПО сделать legacy, причем следуя этой формуле успеха достигает сам разработчик этой самой программы, без чьей либо помощи. Формула проста: **чтобы получить legacy софт, вам необходимо относится к разработке сервисного ПО как будто вы делаете товар**.

Или другими словами: если вы видите, что вы разрабатываете сервис (то есть вы надолго в этом проекте, мы будете еще несколько лет добавлять новые функции в проект, адаптировать его к новым реалиям), однако вы хотите сделать из проекта истинное legacy (то есть программу, в которую невероятно сложно вносить изменения, которая неспособна работать на более новой ОС/железе и т.д.), то просто начните относиться к проекту как к товару. Просто рассматривайте каждый релиз, как последний. Чаще употребляйте слова "ну всё, продали версию". Как можно активнее делайте маленькие костыли и хаки, вместо переработки кода. И напоследок: побольше ручного труда (забудьте про TeamCity/Jenkins), и никогда не пишите документаций, спецификаций и комментариев.

Довольно интересно, что если буквально чуть-чуть изменить отношение к ПО, то оно само будет становится страшным legacy, причем сделанным своими руками.

## Пособие: как же не делать из своих программ legacy

Как ни странно, однако для того, чтобы не получить ужасное ПО на руках, необходимо всего лишь **задавать себе вопрос раз в месяц/квартал: а продукт, который я делаю, это товар или сервис?** И запомнить/записать этот ответ хотя бы на некоторое время (а )

# Что продает [аутсорсер](https://ru.wikipedia.org/wiki/%D0%90%D1%83%D1%82%D1%81%D0%BE%D1%80%D1%81%D0%B8%D0%BD%D0%B3): продукт или сервис?

Пример из жизни: у вас есть компания, которая берет IT проекты сроком на один год (примерно). Далее эти продукты поддерживаются в течении нескольких лет без доплаты от заказчика.

Несмотря на то, что пример про IT компанию и IT проект, самые важные пункты 